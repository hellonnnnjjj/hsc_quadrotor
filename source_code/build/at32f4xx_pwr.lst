ARM GAS  /tmp/ccyyqHbL.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"at32f4xx_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.PWR_Reset,"ax",%progbits
  18              		.align	1
  19              		.global	PWR_Reset
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	PWR_Reset:
  27              	.LFB123:
  28              		.file 1 "./lib/src/at32f4xx_pwr.c"
   1:./lib/src/at32f4xx_pwr.c **** /**
   2:./lib/src/at32f4xx_pwr.c ****   **************************************************************************
   3:./lib/src/at32f4xx_pwr.c ****   * File   : at32f4xx_pwr.c
   4:./lib/src/at32f4xx_pwr.c ****   * Version: V1.2.4
   5:./lib/src/at32f4xx_pwr.c ****   * Date   : 2020-08-26
   6:./lib/src/at32f4xx_pwr.c ****   * Brief  : at32f4xx PWR source file
   7:./lib/src/at32f4xx_pwr.c ****   **************************************************************************
   8:./lib/src/at32f4xx_pwr.c ****   */
   9:./lib/src/at32f4xx_pwr.c **** 
  10:./lib/src/at32f4xx_pwr.c **** 
  11:./lib/src/at32f4xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
  12:./lib/src/at32f4xx_pwr.c **** #include "at32f4xx_pwr.h"
  13:./lib/src/at32f4xx_pwr.c **** #include "at32f4xx_rcc.h"
  14:./lib/src/at32f4xx_pwr.c **** 
  15:./lib/src/at32f4xx_pwr.c **** /** @addtogroup at32f4xx_StdPeriph_Driver
  16:./lib/src/at32f4xx_pwr.c ****   * @{
  17:./lib/src/at32f4xx_pwr.c ****   */
  18:./lib/src/at32f4xx_pwr.c **** 
  19:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR
  20:./lib/src/at32f4xx_pwr.c ****   * @brief PWR driver modules
  21:./lib/src/at32f4xx_pwr.c ****   * @{
  22:./lib/src/at32f4xx_pwr.c ****   */
  23:./lib/src/at32f4xx_pwr.c **** 
  24:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_TypesDefinitions
  25:./lib/src/at32f4xx_pwr.c ****   * @{
  26:./lib/src/at32f4xx_pwr.c ****   */
  27:./lib/src/at32f4xx_pwr.c **** 
  28:./lib/src/at32f4xx_pwr.c **** /**
  29:./lib/src/at32f4xx_pwr.c ****   * @}
  30:./lib/src/at32f4xx_pwr.c ****   */
ARM GAS  /tmp/ccyyqHbL.s 			page 2


  31:./lib/src/at32f4xx_pwr.c **** 
  32:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_Defines
  33:./lib/src/at32f4xx_pwr.c ****   * @{
  34:./lib/src/at32f4xx_pwr.c ****   */
  35:./lib/src/at32f4xx_pwr.c **** 
  36:./lib/src/at32f4xx_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  37:./lib/src/at32f4xx_pwr.c **** #define PWR_OFFSET                  (PWR_BASE - PERIPH_BASE)
  38:./lib/src/at32f4xx_pwr.c **** 
  39:./lib/src/at32f4xx_pwr.c **** /* --- CTRL Register ---*/
  40:./lib/src/at32f4xx_pwr.c **** 
  41:./lib/src/at32f4xx_pwr.c **** /* Alias word address of DBP bit */
  42:./lib/src/at32f4xx_pwr.c **** #define CTRL_OFFSET                 (PWR_OFFSET + 0x00)
  43:./lib/src/at32f4xx_pwr.c **** #define DBP_BitNumber                0x08
  44:./lib/src/at32f4xx_pwr.c **** #define CTRL_DBP_BB                 (PERIPH_BB_BASE + (CTRL_OFFSET * 32) + (DBP_BitNumber * 4))
  45:./lib/src/at32f4xx_pwr.c **** 
  46:./lib/src/at32f4xx_pwr.c **** /* Alias word address of PVDE bit */
  47:./lib/src/at32f4xx_pwr.c **** #define PVDE_BitNumber              0x04
  48:./lib/src/at32f4xx_pwr.c **** #define CTRL_PVDE_BB                (PERIPH_BB_BASE + (CTRL_OFFSET * 32) + (PVDE_BitNumber * 4))
  49:./lib/src/at32f4xx_pwr.c **** 
  50:./lib/src/at32f4xx_pwr.c **** /* --- CTRLSTS Register ---*/
  51:./lib/src/at32f4xx_pwr.c **** 
  52:./lib/src/at32f4xx_pwr.c **** /* Alias word address of EWUP bit */
  53:./lib/src/at32f4xx_pwr.c **** #define CTRLSTS_OFFSET              (PWR_OFFSET + 0x04)
  54:./lib/src/at32f4xx_pwr.c **** #define EWUP_BitNumber              0x08
  55:./lib/src/at32f4xx_pwr.c **** #define CTRLSTS_EWUP_BB             (PERIPH_BB_BASE + (CTRLSTS_OFFSET * 32) + (EWUP_BitNumber * 4))
  56:./lib/src/at32f4xx_pwr.c **** 
  57:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F421xx)
  58:./lib/src/at32f4xx_pwr.c ****   /* Alias word address of EWUP2 bit */
  59:./lib/src/at32f4xx_pwr.c ****   #define EWUP_BitNumber2           0x09
  60:./lib/src/at32f4xx_pwr.c ****   #define CTRLSTS_EWUP_BB2          (PERIPH_BB_BASE + (CTRLSTS_OFFSET * 32) + (EWUP_BitNumber2 * 4)
  61:./lib/src/at32f4xx_pwr.c **** 
  62:./lib/src/at32f4xx_pwr.c ****   /* Alias word address of EWUP6 bit */
  63:./lib/src/at32f4xx_pwr.c ****   #define EWUP_BitNumber6           0x0D
  64:./lib/src/at32f4xx_pwr.c ****   #define CTRLSTS_EWUP_BB6          (PERIPH_BB_BASE + (CTRLSTS_OFFSET * 32) + (EWUP_BitNumber6 * 4)
  65:./lib/src/at32f4xx_pwr.c **** 
  66:./lib/src/at32f4xx_pwr.c ****   /* Alias word address of EWUP7 bit */
  67:./lib/src/at32f4xx_pwr.c ****   #define EWUP_BitNumber7           0x0E
  68:./lib/src/at32f4xx_pwr.c ****   #define CTRLSTS_EWUP_BB7          (PERIPH_BB_BASE + (CTRLSTS_OFFSET * 32) + (EWUP_BitNumber7 * 4)
  69:./lib/src/at32f4xx_pwr.c **** #endif
  70:./lib/src/at32f4xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
  71:./lib/src/at32f4xx_pwr.c **** 
  72:./lib/src/at32f4xx_pwr.c **** /* CTRL register bit mask */
  73:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F403xx) || defined (AT32F413xx)
  74:./lib/src/at32f4xx_pwr.c ****   #define CTRL_LPDS_MASK            ((uint32_t)0x00000002)
  75:./lib/src/at32f4xx_pwr.c **** #else
  76:./lib/src/at32f4xx_pwr.c ****   #define CTRL_LPDS_MASK            ((uint32_t)0x00000003)
  77:./lib/src/at32f4xx_pwr.c **** #endif
  78:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F421xx)
  79:./lib/src/at32f4xx_pwr.c ****   #define CTRL2_LPDS1_MASK          ((uint32_t)0x00000020)
  80:./lib/src/at32f4xx_pwr.c **** #endif
  81:./lib/src/at32f4xx_pwr.c **** #define CTRL_PVDS_MASK              ((uint32_t)0x000000E0)
  82:./lib/src/at32f4xx_pwr.c **** 
  83:./lib/src/at32f4xx_pwr.c **** 
  84:./lib/src/at32f4xx_pwr.c **** /**
  85:./lib/src/at32f4xx_pwr.c ****   * @}
  86:./lib/src/at32f4xx_pwr.c ****   */
  87:./lib/src/at32f4xx_pwr.c **** 
ARM GAS  /tmp/ccyyqHbL.s 			page 3


  88:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_Macros
  89:./lib/src/at32f4xx_pwr.c ****   * @{
  90:./lib/src/at32f4xx_pwr.c ****   */
  91:./lib/src/at32f4xx_pwr.c **** 
  92:./lib/src/at32f4xx_pwr.c **** /**
  93:./lib/src/at32f4xx_pwr.c ****   * @}
  94:./lib/src/at32f4xx_pwr.c ****   */
  95:./lib/src/at32f4xx_pwr.c **** 
  96:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_Variables
  97:./lib/src/at32f4xx_pwr.c ****   * @{
  98:./lib/src/at32f4xx_pwr.c ****   */
  99:./lib/src/at32f4xx_pwr.c **** 
 100:./lib/src/at32f4xx_pwr.c **** /**
 101:./lib/src/at32f4xx_pwr.c ****   * @}
 102:./lib/src/at32f4xx_pwr.c ****   */
 103:./lib/src/at32f4xx_pwr.c **** 
 104:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_FunctionPrototypes
 105:./lib/src/at32f4xx_pwr.c ****   * @{
 106:./lib/src/at32f4xx_pwr.c ****   */
 107:./lib/src/at32f4xx_pwr.c **** 
 108:./lib/src/at32f4xx_pwr.c **** /**
 109:./lib/src/at32f4xx_pwr.c ****   * @}
 110:./lib/src/at32f4xx_pwr.c ****   */
 111:./lib/src/at32f4xx_pwr.c **** 
 112:./lib/src/at32f4xx_pwr.c **** /** @defgroup PWR_Private_Functions
 113:./lib/src/at32f4xx_pwr.c ****   * @{
 114:./lib/src/at32f4xx_pwr.c ****   */
 115:./lib/src/at32f4xx_pwr.c **** 
 116:./lib/src/at32f4xx_pwr.c **** /**
 117:./lib/src/at32f4xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.
 118:./lib/src/at32f4xx_pwr.c ****   * @param  None
 119:./lib/src/at32f4xx_pwr.c ****   * @retval None
 120:./lib/src/at32f4xx_pwr.c ****   */
 121:./lib/src/at32f4xx_pwr.c **** void PWR_Reset(void)
 122:./lib/src/at32f4xx_pwr.c **** {
  29              		.loc 1 122 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 08B5     		push	{r3, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 3, -8
  37              		.cfi_offset 14, -4
 123:./lib/src/at32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1PERIPH_PWR, ENABLE);
  38              		.loc 1 123 3 view .LVU1
  39 0002 0121     		movs	r1, #1
  40 0004 4FF08050 		mov	r0, #268435456
  41 0008 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  42              	.LVL0:
 124:./lib/src/at32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1PERIPH_PWR, DISABLE);
  43              		.loc 1 124 3 view .LVU2
  44 000c 0021     		movs	r1, #0
  45 000e 4FF08050 		mov	r0, #268435456
  46 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  47              	.LVL1:
 125:./lib/src/at32f4xx_pwr.c **** }
ARM GAS  /tmp/ccyyqHbL.s 			page 4


  48              		.loc 1 125 1 is_stmt 0 view .LVU3
  49 0016 08BD     		pop	{r3, pc}
  50              		.cfi_endproc
  51              	.LFE123:
  53              		.section	.text.PWR_BackupAccessCtrl,"ax",%progbits
  54              		.align	1
  55              		.global	PWR_BackupAccessCtrl
  56              		.syntax unified
  57              		.thumb
  58              		.thumb_func
  59              		.fpu fpv4-sp-d16
  61              	PWR_BackupAccessCtrl:
  62              	.LVL2:
  63              	.LFB124:
 126:./lib/src/at32f4xx_pwr.c **** 
 127:./lib/src/at32f4xx_pwr.c **** /**
 128:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables access to the RTC and backup registers.
 129:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the access to the RTC and backup registers.
 130:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 131:./lib/src/at32f4xx_pwr.c ****   * @retval None
 132:./lib/src/at32f4xx_pwr.c ****   */
 133:./lib/src/at32f4xx_pwr.c **** void PWR_BackupAccessCtrl(FunctionalState NewState)
 134:./lib/src/at32f4xx_pwr.c **** {
  64              		.loc 1 134 1 is_stmt 1 view -0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
 135:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 136:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
  69              		.loc 1 136 3 view .LVU5
 137:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRL_DBP_BB = (uint32_t)NewState;
  70              		.loc 1 137 3 view .LVU6
  71              		.loc 1 137 34 is_stmt 0 view .LVU7
  72 0000 014B     		ldr	r3, .L4
  73 0002 1862     		str	r0, [r3, #32]
 138:./lib/src/at32f4xx_pwr.c **** }
  74              		.loc 1 138 1 view .LVU8
  75 0004 7047     		bx	lr
  76              	.L5:
  77 0006 00BF     		.align	2
  78              	.L4:
  79 0008 00000E42 		.word	1108213760
  80              		.cfi_endproc
  81              	.LFE124:
  83              		.section	.text.PWR_PVDCtrl,"ax",%progbits
  84              		.align	1
  85              		.global	PWR_PVDCtrl
  86              		.syntax unified
  87              		.thumb
  88              		.thumb_func
  89              		.fpu fpv4-sp-d16
  91              	PWR_PVDCtrl:
  92              	.LVL3:
  93              	.LFB125:
 139:./lib/src/at32f4xx_pwr.c **** 
 140:./lib/src/at32f4xx_pwr.c **** /**
ARM GAS  /tmp/ccyyqHbL.s 			page 5


 141:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 142:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the PVD.
 143:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 144:./lib/src/at32f4xx_pwr.c ****   * @retval None
 145:./lib/src/at32f4xx_pwr.c ****   */
 146:./lib/src/at32f4xx_pwr.c **** void PWR_PVDCtrl(FunctionalState NewState)
 147:./lib/src/at32f4xx_pwr.c **** {
  94              		.loc 1 147 1 is_stmt 1 view -0
  95              		.cfi_startproc
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
 148:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 149:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
  99              		.loc 1 149 3 view .LVU10
 150:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRL_PVDE_BB = (uint32_t)NewState;
 100              		.loc 1 150 3 view .LVU11
 101              		.loc 1 150 35 is_stmt 0 view .LVU12
 102 0000 014B     		ldr	r3, .L7
 103 0002 1861     		str	r0, [r3, #16]
 151:./lib/src/at32f4xx_pwr.c **** }
 104              		.loc 1 151 1 view .LVU13
 105 0004 7047     		bx	lr
 106              	.L8:
 107 0006 00BF     		.align	2
 108              	.L7:
 109 0008 00000E42 		.word	1108213760
 110              		.cfi_endproc
 111              	.LFE125:
 113              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
 114              		.align	1
 115              		.global	PWR_PVDLevelConfig
 116              		.syntax unified
 117              		.thumb
 118              		.thumb_func
 119              		.fpu fpv4-sp-d16
 121              	PWR_PVDLevelConfig:
 122              	.LVL4:
 123              	.LFB126:
 152:./lib/src/at32f4xx_pwr.c **** 
 153:./lib/src/at32f4xx_pwr.c **** /**
 154:./lib/src/at32f4xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 155:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 156:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 157:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V2: PVD detection level set to 2.2V
 158:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V3: PVD detection level set to 2.3V
 159:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V4: PVD detection level set to 2.4V
 160:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V5: PVD detection level set to 2.5V
 161:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V6: PVD detection level set to 2.6V
 162:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V7: PVD detection level set to 2.7V
 163:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V8: PVD detection level set to 2.8V
 164:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_PVDS_2V9: PVD detection level set to 2.9V
 165:./lib/src/at32f4xx_pwr.c ****   * @retval None
 166:./lib/src/at32f4xx_pwr.c ****   */
 167:./lib/src/at32f4xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 168:./lib/src/at32f4xx_pwr.c **** {
 124              		.loc 1 168 1 is_stmt 1 view -0
ARM GAS  /tmp/ccyyqHbL.s 			page 6


 125              		.cfi_startproc
 126              		@ args = 0, pretend = 0, frame = 0
 127              		@ frame_needed = 0, uses_anonymous_args = 0
 128              		@ link register save eliminated.
 169:./lib/src/at32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 129              		.loc 1 169 3 view .LVU15
 170:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 171:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 130              		.loc 1 171 3 view .LVU16
 172:./lib/src/at32f4xx_pwr.c ****   tmpreg = PWR->CTRL;
 131              		.loc 1 172 3 view .LVU17
 132              		.loc 1 172 10 is_stmt 0 view .LVU18
 133 0000 034A     		ldr	r2, .L10
 134 0002 1368     		ldr	r3, [r2]
 135              	.LVL5:
 173:./lib/src/at32f4xx_pwr.c ****   /* Clear PLS[7:5] bits */
 174:./lib/src/at32f4xx_pwr.c ****   tmpreg &= ~CTRL_PVDS_MASK;
 136              		.loc 1 174 3 is_stmt 1 view .LVU19
 137              		.loc 1 174 10 is_stmt 0 view .LVU20
 138 0004 23F0E003 		bic	r3, r3, #224
 139              	.LVL6:
 175:./lib/src/at32f4xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 176:./lib/src/at32f4xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
 140              		.loc 1 176 3 is_stmt 1 view .LVU21
 141              		.loc 1 176 10 is_stmt 0 view .LVU22
 142 0008 0343     		orrs	r3, r3, r0
 143              	.LVL7:
 177:./lib/src/at32f4xx_pwr.c ****   /* Store the new value */
 178:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL = tmpreg;
 144              		.loc 1 178 3 is_stmt 1 view .LVU23
 145              		.loc 1 178 13 is_stmt 0 view .LVU24
 146 000a 1360     		str	r3, [r2]
 179:./lib/src/at32f4xx_pwr.c **** }
 147              		.loc 1 179 1 view .LVU25
 148 000c 7047     		bx	lr
 149              	.L11:
 150 000e 00BF     		.align	2
 151              	.L10:
 152 0010 00700040 		.word	1073770496
 153              		.cfi_endproc
 154              	.LFE126:
 156              		.section	.text.PWR_WakeUpPinCtrl,"ax",%progbits
 157              		.align	1
 158              		.global	PWR_WakeUpPinCtrl
 159              		.syntax unified
 160              		.thumb
 161              		.thumb_func
 162              		.fpu fpv4-sp-d16
 164              	PWR_WakeUpPinCtrl:
 165              	.LVL8:
 166              	.LFB127:
 180:./lib/src/at32f4xx_pwr.c **** 
 181:./lib/src/at32f4xx_pwr.c **** /**
 182:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 183:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 184:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 185:./lib/src/at32f4xx_pwr.c ****   * @retval None
ARM GAS  /tmp/ccyyqHbL.s 			page 7


 186:./lib/src/at32f4xx_pwr.c ****   */
 187:./lib/src/at32f4xx_pwr.c **** void PWR_WakeUpPinCtrl(FunctionalState NewState)
 188:./lib/src/at32f4xx_pwr.c **** {
 167              		.loc 1 188 1 is_stmt 1 view -0
 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 0
 170              		@ frame_needed = 0, uses_anonymous_args = 0
 171              		@ link register save eliminated.
 189:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 190:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 172              		.loc 1 190 3 view .LVU27
 191:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRLSTS_EWUP_BB = (uint32_t)NewState;
 173              		.loc 1 191 3 view .LVU28
 174              		.loc 1 191 38 is_stmt 0 view .LVU29
 175 0000 014B     		ldr	r3, .L13
 176 0002 C3F8A000 		str	r0, [r3, #160]
 192:./lib/src/at32f4xx_pwr.c **** }
 177              		.loc 1 192 1 view .LVU30
 178 0006 7047     		bx	lr
 179              	.L14:
 180              		.align	2
 181              	.L13:
 182 0008 00000E42 		.word	1108213760
 183              		.cfi_endproc
 184              	.LFE127:
 186              		.section	.text.PWR_WakeUpPinCtrl2,"ax",%progbits
 187              		.align	1
 188              		.global	PWR_WakeUpPinCtrl2
 189              		.syntax unified
 190              		.thumb
 191              		.thumb_func
 192              		.fpu fpv4-sp-d16
 194              	PWR_WakeUpPinCtrl2:
 195              	.LVL9:
 196              	.LFB128:
 193:./lib/src/at32f4xx_pwr.c **** 
 194:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F421xx)
 195:./lib/src/at32f4xx_pwr.c **** /**
 196:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin2 functionality.
 197:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin2 functionality.
 198:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 199:./lib/src/at32f4xx_pwr.c ****   * @retval None
 200:./lib/src/at32f4xx_pwr.c ****   */
 201:./lib/src/at32f4xx_pwr.c **** void PWR_WakeUpPinCtrl2(FunctionalState NewState)
 202:./lib/src/at32f4xx_pwr.c **** {
 197              		.loc 1 202 1 is_stmt 1 view -0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 203:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 204:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 202              		.loc 1 204 3 view .LVU32
 205:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRLSTS_EWUP_BB2 = (uint32_t)NewState;
 203              		.loc 1 205 3 view .LVU33
 204              		.loc 1 205 39 is_stmt 0 view .LVU34
 205 0000 014B     		ldr	r3, .L16
ARM GAS  /tmp/ccyyqHbL.s 			page 8


 206 0002 C3F8A400 		str	r0, [r3, #164]
 206:./lib/src/at32f4xx_pwr.c **** }
 207              		.loc 1 206 1 view .LVU35
 208 0006 7047     		bx	lr
 209              	.L17:
 210              		.align	2
 211              	.L16:
 212 0008 00000E42 		.word	1108213760
 213              		.cfi_endproc
 214              	.LFE128:
 216              		.section	.text.PWR_WakeUpPinCtrl6,"ax",%progbits
 217              		.align	1
 218              		.global	PWR_WakeUpPinCtrl6
 219              		.syntax unified
 220              		.thumb
 221              		.thumb_func
 222              		.fpu fpv4-sp-d16
 224              	PWR_WakeUpPinCtrl6:
 225              	.LVL10:
 226              	.LFB129:
 207:./lib/src/at32f4xx_pwr.c **** 
 208:./lib/src/at32f4xx_pwr.c **** /**
 209:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin6 functionality.
 210:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin6 functionality.
 211:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 212:./lib/src/at32f4xx_pwr.c ****   * @retval None
 213:./lib/src/at32f4xx_pwr.c ****   */
 214:./lib/src/at32f4xx_pwr.c **** void PWR_WakeUpPinCtrl6(FunctionalState NewState)
 215:./lib/src/at32f4xx_pwr.c **** {
 227              		.loc 1 215 1 is_stmt 1 view -0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              		@ link register save eliminated.
 216:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 217:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 232              		.loc 1 217 3 view .LVU37
 218:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRLSTS_EWUP_BB6 = (uint32_t)NewState;
 233              		.loc 1 218 3 view .LVU38
 234              		.loc 1 218 39 is_stmt 0 view .LVU39
 235 0000 014B     		ldr	r3, .L19
 236 0002 C3F8B400 		str	r0, [r3, #180]
 219:./lib/src/at32f4xx_pwr.c **** }
 237              		.loc 1 219 1 view .LVU40
 238 0006 7047     		bx	lr
 239              	.L20:
 240              		.align	2
 241              	.L19:
 242 0008 00000E42 		.word	1108213760
 243              		.cfi_endproc
 244              	.LFE129:
 246              		.section	.text.PWR_WakeUpPinCtrl7,"ax",%progbits
 247              		.align	1
 248              		.global	PWR_WakeUpPinCtrl7
 249              		.syntax unified
 250              		.thumb
 251              		.thumb_func
ARM GAS  /tmp/ccyyqHbL.s 			page 9


 252              		.fpu fpv4-sp-d16
 254              	PWR_WakeUpPinCtrl7:
 255              	.LVL11:
 256              	.LFB130:
 220:./lib/src/at32f4xx_pwr.c **** 
 221:./lib/src/at32f4xx_pwr.c **** /**
 222:./lib/src/at32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin7 functionality.
 223:./lib/src/at32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin7 functionality.
 224:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 225:./lib/src/at32f4xx_pwr.c ****   * @retval None
 226:./lib/src/at32f4xx_pwr.c ****   */
 227:./lib/src/at32f4xx_pwr.c **** void PWR_WakeUpPinCtrl7(FunctionalState NewState)
 228:./lib/src/at32f4xx_pwr.c **** {
 257              		.loc 1 228 1 is_stmt 1 view -0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 0
 260              		@ frame_needed = 0, uses_anonymous_args = 0
 261              		@ link register save eliminated.
 229:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 230:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 262              		.loc 1 230 3 view .LVU42
 231:./lib/src/at32f4xx_pwr.c ****   *(__IO uint32_t *) CTRLSTS_EWUP_BB7 = (uint32_t)NewState;
 263              		.loc 1 231 3 view .LVU43
 264              		.loc 1 231 39 is_stmt 0 view .LVU44
 265 0000 014B     		ldr	r3, .L22
 266 0002 C3F8B800 		str	r0, [r3, #184]
 232:./lib/src/at32f4xx_pwr.c **** }
 267              		.loc 1 232 1 view .LVU45
 268 0006 7047     		bx	lr
 269              	.L23:
 270              		.align	2
 271              	.L22:
 272 0008 00000E42 		.word	1108213760
 273              		.cfi_endproc
 274              	.LFE130:
 276              		.section	.text.PWR_EnterSleepMode,"ax",%progbits
 277              		.align	1
 278              		.global	PWR_EnterSleepMode
 279              		.syntax unified
 280              		.thumb
 281              		.thumb_func
 282              		.fpu fpv4-sp-d16
 284              	PWR_EnterSleepMode:
 285              	.LVL12:
 286              	.LFB131:
 233:./lib/src/at32f4xx_pwr.c **** #endif
 234:./lib/src/at32f4xx_pwr.c **** 
 235:./lib/src/at32f4xx_pwr.c **** /**
 236:./lib/src/at32f4xx_pwr.c ****   * @brief  Enters Sleep mode.
 237:./lib/src/at32f4xx_pwr.c ****   * @note   In Sleep mode, all I/O pins keep the same state as in Run mode.
 238:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_SLEEPEntry: specifies if SLEEP mode in entered with WFI or WFE instruction.
 239:./lib/src/at32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 240:./lib/src/at32f4xx_pwr.c ****   *             @arg PWR_SLEEPEntry_WFI: enter SLEEP mode with WFI instruction
 241:./lib/src/at32f4xx_pwr.c ****   *             @arg PWR_SLEEPEntry_WFE: enter SLEEP mode with WFE instruction
 242:./lib/src/at32f4xx_pwr.c ****   * @retval None
 243:./lib/src/at32f4xx_pwr.c ****   */
 244:./lib/src/at32f4xx_pwr.c **** void PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry)
ARM GAS  /tmp/ccyyqHbL.s 			page 10


 245:./lib/src/at32f4xx_pwr.c **** {
 287              		.loc 1 245 1 is_stmt 1 view -0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 0
 290              		@ frame_needed = 0, uses_anonymous_args = 0
 291              		@ link register save eliminated.
 246:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 247:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
 292              		.loc 1 247 3 view .LVU47
 248:./lib/src/at32f4xx_pwr.c **** 
 249:./lib/src/at32f4xx_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 250:./lib/src/at32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 293              		.loc 1 250 3 view .LVU48
 294              		.loc 1 250 12 is_stmt 0 view .LVU49
 295 0000 064A     		ldr	r2, .L28
 296 0002 1369     		ldr	r3, [r2, #16]
 297 0004 23F00403 		bic	r3, r3, #4
 298 0008 1361     		str	r3, [r2, #16]
 251:./lib/src/at32f4xx_pwr.c ****   
 252:./lib/src/at32f4xx_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 253:./lib/src/at32f4xx_pwr.c ****   if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
 299              		.loc 1 253 3 is_stmt 1 view .LVU50
 300              		.loc 1 253 5 is_stmt 0 view .LVU51
 301 000a 0128     		cmp	r0, #1
 302 000c 03D0     		beq	.L27
 254:./lib/src/at32f4xx_pwr.c ****   {
 255:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 256:./lib/src/at32f4xx_pwr.c ****     __WFI();
 257:./lib/src/at32f4xx_pwr.c ****   }
 258:./lib/src/at32f4xx_pwr.c ****   else
 259:./lib/src/at32f4xx_pwr.c ****   {
 260:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Event */
 261:./lib/src/at32f4xx_pwr.c ****     __SEV();
 303              		.loc 1 261 5 is_stmt 1 view .LVU52
 304              	.LBB20:
 305              	.LBI20:
 306              		.file 2 "CMSIS/cmsis_gcc.h"
   1:CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:CMSIS/cmsis_gcc.h ****  * File   :cmsis_gcc.h
   3:CMSIS/cmsis_gcc.h ****  * Brief  :CMSIS Cortex-M Core Function/Instruction Header File
   4:CMSIS/cmsis_gcc.h ****  * Version:V4.30
   5:CMSIS/cmsis_gcc.h ****  * Date   :20. October 2015
   6:CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:CMSIS/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:CMSIS/cmsis_gcc.h **** 
   9:CMSIS/cmsis_gcc.h ****    All rights reserved.
  10:CMSIS/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:CMSIS/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:CMSIS/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:CMSIS/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:CMSIS/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:CMSIS/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:CMSIS/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:CMSIS/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:CMSIS/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:CMSIS/cmsis_gcc.h ****      specific prior written permission.
  20:CMSIS/cmsis_gcc.h ****    *
ARM GAS  /tmp/ccyyqHbL.s 			page 11


  21:CMSIS/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:CMSIS/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:CMSIS/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:CMSIS/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:CMSIS/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:CMSIS/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:CMSIS/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:CMSIS/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:CMSIS/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:CMSIS/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:CMSIS/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:CMSIS/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:CMSIS/cmsis_gcc.h **** 
  34:CMSIS/cmsis_gcc.h **** 
  35:CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:CMSIS/cmsis_gcc.h **** 
  38:CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:CMSIS/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:CMSIS/cmsis_gcc.h **** #endif
  45:CMSIS/cmsis_gcc.h **** 
  46:CMSIS/cmsis_gcc.h **** 
  47:CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:CMSIS/cmsis_gcc.h ****   @{
  51:CMSIS/cmsis_gcc.h ****  */
  52:CMSIS/cmsis_gcc.h **** 
  53:CMSIS/cmsis_gcc.h **** /**
  54:CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:CMSIS/cmsis_gcc.h ****  */
  58:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:CMSIS/cmsis_gcc.h **** {
  60:CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:CMSIS/cmsis_gcc.h **** }
  62:CMSIS/cmsis_gcc.h **** 
  63:CMSIS/cmsis_gcc.h **** 
  64:CMSIS/cmsis_gcc.h **** /**
  65:CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:CMSIS/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:CMSIS/cmsis_gcc.h ****  */
  69:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:CMSIS/cmsis_gcc.h **** {
  71:CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:CMSIS/cmsis_gcc.h **** }
  73:CMSIS/cmsis_gcc.h **** 
  74:CMSIS/cmsis_gcc.h **** 
  75:CMSIS/cmsis_gcc.h **** /**
  76:CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
  77:CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
ARM GAS  /tmp/ccyyqHbL.s 			page 12


  78:CMSIS/cmsis_gcc.h ****   \return               Control Register value
  79:CMSIS/cmsis_gcc.h ****  */
  80:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:CMSIS/cmsis_gcc.h **** {
  82:CMSIS/cmsis_gcc.h ****   uint32_t result;
  83:CMSIS/cmsis_gcc.h **** 
  84:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:CMSIS/cmsis_gcc.h ****   return(result);
  86:CMSIS/cmsis_gcc.h **** }
  87:CMSIS/cmsis_gcc.h **** 
  88:CMSIS/cmsis_gcc.h **** 
  89:CMSIS/cmsis_gcc.h **** /**
  90:CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
  91:CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:CMSIS/cmsis_gcc.h ****  */
  94:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:CMSIS/cmsis_gcc.h **** {
  96:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:CMSIS/cmsis_gcc.h **** }
  98:CMSIS/cmsis_gcc.h **** 
  99:CMSIS/cmsis_gcc.h **** 
 100:CMSIS/cmsis_gcc.h **** /**
 101:CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 104:CMSIS/cmsis_gcc.h ****  */
 105:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:CMSIS/cmsis_gcc.h **** {
 107:CMSIS/cmsis_gcc.h ****   uint32_t result;
 108:CMSIS/cmsis_gcc.h **** 
 109:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:CMSIS/cmsis_gcc.h ****   return(result);
 111:CMSIS/cmsis_gcc.h **** }
 112:CMSIS/cmsis_gcc.h **** 
 113:CMSIS/cmsis_gcc.h **** 
 114:CMSIS/cmsis_gcc.h **** /**
 115:CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 116:CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 118:CMSIS/cmsis_gcc.h ****  */
 119:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:CMSIS/cmsis_gcc.h **** {
 121:CMSIS/cmsis_gcc.h ****   uint32_t result;
 122:CMSIS/cmsis_gcc.h **** 
 123:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:CMSIS/cmsis_gcc.h ****   return(result);
 125:CMSIS/cmsis_gcc.h **** }
 126:CMSIS/cmsis_gcc.h **** 
 127:CMSIS/cmsis_gcc.h **** 
 128:CMSIS/cmsis_gcc.h **** /**
 129:CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:CMSIS/cmsis_gcc.h **** 
 132:CMSIS/cmsis_gcc.h ****     \return               xPSR Register value
 133:CMSIS/cmsis_gcc.h ****  */
 134:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
ARM GAS  /tmp/ccyyqHbL.s 			page 13


 135:CMSIS/cmsis_gcc.h **** {
 136:CMSIS/cmsis_gcc.h ****   uint32_t result;
 137:CMSIS/cmsis_gcc.h **** 
 138:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:CMSIS/cmsis_gcc.h ****   return(result);
 140:CMSIS/cmsis_gcc.h **** }
 141:CMSIS/cmsis_gcc.h **** 
 142:CMSIS/cmsis_gcc.h **** 
 143:CMSIS/cmsis_gcc.h **** /**
 144:CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 147:CMSIS/cmsis_gcc.h ****  */
 148:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:CMSIS/cmsis_gcc.h **** {
 150:CMSIS/cmsis_gcc.h ****   register uint32_t result;
 151:CMSIS/cmsis_gcc.h **** 
 152:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:CMSIS/cmsis_gcc.h ****   return(result);
 154:CMSIS/cmsis_gcc.h **** }
 155:CMSIS/cmsis_gcc.h **** 
 156:CMSIS/cmsis_gcc.h **** 
 157:CMSIS/cmsis_gcc.h **** /**
 158:CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:CMSIS/cmsis_gcc.h ****  */
 162:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:CMSIS/cmsis_gcc.h **** {
 164:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:CMSIS/cmsis_gcc.h **** }
 166:CMSIS/cmsis_gcc.h **** 
 167:CMSIS/cmsis_gcc.h **** 
 168:CMSIS/cmsis_gcc.h **** /**
 169:CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 172:CMSIS/cmsis_gcc.h ****  */
 173:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:CMSIS/cmsis_gcc.h **** {
 175:CMSIS/cmsis_gcc.h ****   register uint32_t result;
 176:CMSIS/cmsis_gcc.h **** 
 177:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:CMSIS/cmsis_gcc.h ****   return(result);
 179:CMSIS/cmsis_gcc.h **** }
 180:CMSIS/cmsis_gcc.h **** 
 181:CMSIS/cmsis_gcc.h **** 
 182:CMSIS/cmsis_gcc.h **** /**
 183:CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:CMSIS/cmsis_gcc.h **** 
 186:CMSIS/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:CMSIS/cmsis_gcc.h ****  */
 188:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:CMSIS/cmsis_gcc.h **** {
 190:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:CMSIS/cmsis_gcc.h **** }
ARM GAS  /tmp/ccyyqHbL.s 			page 14


 192:CMSIS/cmsis_gcc.h **** 
 193:CMSIS/cmsis_gcc.h **** 
 194:CMSIS/cmsis_gcc.h **** /**
 195:CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 198:CMSIS/cmsis_gcc.h ****  */
 199:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:CMSIS/cmsis_gcc.h **** {
 201:CMSIS/cmsis_gcc.h ****   uint32_t result;
 202:CMSIS/cmsis_gcc.h **** 
 203:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:CMSIS/cmsis_gcc.h ****   return(result);
 205:CMSIS/cmsis_gcc.h **** }
 206:CMSIS/cmsis_gcc.h **** 
 207:CMSIS/cmsis_gcc.h **** 
 208:CMSIS/cmsis_gcc.h **** /**
 209:CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:CMSIS/cmsis_gcc.h ****  */
 213:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:CMSIS/cmsis_gcc.h **** {
 215:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:CMSIS/cmsis_gcc.h **** }
 217:CMSIS/cmsis_gcc.h **** 
 218:CMSIS/cmsis_gcc.h **** 
 219:CMSIS/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:CMSIS/cmsis_gcc.h **** 
 221:CMSIS/cmsis_gcc.h **** /**
 222:CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 223:CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:CMSIS/cmsis_gcc.h ****  */
 226:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:CMSIS/cmsis_gcc.h **** {
 228:CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:CMSIS/cmsis_gcc.h **** }
 230:CMSIS/cmsis_gcc.h **** 
 231:CMSIS/cmsis_gcc.h **** 
 232:CMSIS/cmsis_gcc.h **** /**
 233:CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 234:CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:CMSIS/cmsis_gcc.h ****  */
 237:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:CMSIS/cmsis_gcc.h **** {
 239:CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:CMSIS/cmsis_gcc.h **** }
 241:CMSIS/cmsis_gcc.h **** 
 242:CMSIS/cmsis_gcc.h **** 
 243:CMSIS/cmsis_gcc.h **** /**
 244:CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 245:CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 247:CMSIS/cmsis_gcc.h ****  */
 248:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
ARM GAS  /tmp/ccyyqHbL.s 			page 15


 249:CMSIS/cmsis_gcc.h **** {
 250:CMSIS/cmsis_gcc.h ****   uint32_t result;
 251:CMSIS/cmsis_gcc.h **** 
 252:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:CMSIS/cmsis_gcc.h ****   return(result);
 254:CMSIS/cmsis_gcc.h **** }
 255:CMSIS/cmsis_gcc.h **** 
 256:CMSIS/cmsis_gcc.h **** 
 257:CMSIS/cmsis_gcc.h **** /**
 258:CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 259:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:CMSIS/cmsis_gcc.h ****  */
 262:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:CMSIS/cmsis_gcc.h **** {
 264:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:CMSIS/cmsis_gcc.h **** }
 266:CMSIS/cmsis_gcc.h **** 
 267:CMSIS/cmsis_gcc.h **** 
 268:CMSIS/cmsis_gcc.h **** /**
 269:CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:CMSIS/cmsis_gcc.h ****  */
 274:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:CMSIS/cmsis_gcc.h **** {
 276:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:CMSIS/cmsis_gcc.h **** }
 278:CMSIS/cmsis_gcc.h **** 
 279:CMSIS/cmsis_gcc.h **** 
 280:CMSIS/cmsis_gcc.h **** /**
 281:CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 284:CMSIS/cmsis_gcc.h ****  */
 285:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:CMSIS/cmsis_gcc.h **** {
 287:CMSIS/cmsis_gcc.h ****   uint32_t result;
 288:CMSIS/cmsis_gcc.h **** 
 289:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:CMSIS/cmsis_gcc.h ****   return(result);
 291:CMSIS/cmsis_gcc.h **** }
 292:CMSIS/cmsis_gcc.h **** 
 293:CMSIS/cmsis_gcc.h **** 
 294:CMSIS/cmsis_gcc.h **** /**
 295:CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:CMSIS/cmsis_gcc.h ****  */
 299:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:CMSIS/cmsis_gcc.h **** {
 301:CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:CMSIS/cmsis_gcc.h **** }
 303:CMSIS/cmsis_gcc.h **** 
 304:CMSIS/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:CMSIS/cmsis_gcc.h **** 
ARM GAS  /tmp/ccyyqHbL.s 			page 16


 306:CMSIS/cmsis_gcc.h **** 
 307:CMSIS/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:CMSIS/cmsis_gcc.h **** 
 309:CMSIS/cmsis_gcc.h **** /**
 310:CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 311:CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:CMSIS/cmsis_gcc.h ****  */
 314:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:CMSIS/cmsis_gcc.h **** {
 316:CMSIS/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:CMSIS/cmsis_gcc.h ****   uint32_t result;
 318:CMSIS/cmsis_gcc.h **** 
 319:CMSIS/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 321:CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 323:CMSIS/cmsis_gcc.h ****   return(result);
 324:CMSIS/cmsis_gcc.h **** #else
 325:CMSIS/cmsis_gcc.h ****    return(0);
 326:CMSIS/cmsis_gcc.h **** #endif
 327:CMSIS/cmsis_gcc.h **** }
 328:CMSIS/cmsis_gcc.h **** 
 329:CMSIS/cmsis_gcc.h **** 
 330:CMSIS/cmsis_gcc.h **** /**
 331:CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 332:CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:CMSIS/cmsis_gcc.h ****  */
 335:CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:CMSIS/cmsis_gcc.h **** {
 337:CMSIS/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:CMSIS/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 340:CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 342:CMSIS/cmsis_gcc.h **** #endif
 343:CMSIS/cmsis_gcc.h **** }
 344:CMSIS/cmsis_gcc.h **** 
 345:CMSIS/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:CMSIS/cmsis_gcc.h **** 
 347:CMSIS/cmsis_gcc.h **** 
 348:CMSIS/cmsis_gcc.h **** 
 349:CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:CMSIS/cmsis_gcc.h **** 
 351:CMSIS/cmsis_gcc.h **** 
 352:CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 355:CMSIS/cmsis_gcc.h ****   @{
 356:CMSIS/cmsis_gcc.h **** */
 357:CMSIS/cmsis_gcc.h **** 
 358:CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
ARM GAS  /tmp/ccyyqHbL.s 			page 17


 363:CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:CMSIS/cmsis_gcc.h **** #else
 365:CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:CMSIS/cmsis_gcc.h **** #endif
 368:CMSIS/cmsis_gcc.h **** 
 369:CMSIS/cmsis_gcc.h **** /**
 370:CMSIS/cmsis_gcc.h ****   \brief   No Operation
 371:CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:CMSIS/cmsis_gcc.h ****  */
 373:CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:CMSIS/cmsis_gcc.h **** {
 375:CMSIS/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:CMSIS/cmsis_gcc.h **** }
 377:CMSIS/cmsis_gcc.h **** 
 378:CMSIS/cmsis_gcc.h **** 
 379:CMSIS/cmsis_gcc.h **** /**
 380:CMSIS/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:CMSIS/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:CMSIS/cmsis_gcc.h ****  */
 383:CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:CMSIS/cmsis_gcc.h **** {
 385:CMSIS/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:CMSIS/cmsis_gcc.h **** }
 387:CMSIS/cmsis_gcc.h **** 
 388:CMSIS/cmsis_gcc.h **** 
 389:CMSIS/cmsis_gcc.h **** /**
 390:CMSIS/cmsis_gcc.h ****   \brief   Wait For Event
 391:CMSIS/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:CMSIS/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:CMSIS/cmsis_gcc.h ****  */
 394:CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:CMSIS/cmsis_gcc.h **** {
 396:CMSIS/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:CMSIS/cmsis_gcc.h **** }
 398:CMSIS/cmsis_gcc.h **** 
 399:CMSIS/cmsis_gcc.h **** 
 400:CMSIS/cmsis_gcc.h **** /**
 401:CMSIS/cmsis_gcc.h ****   \brief   Send Event
 402:CMSIS/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:CMSIS/cmsis_gcc.h ****  */
 404:CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 307              		.loc 2 404 53 view .LVU53
 308              	.LBB21:
 405:CMSIS/cmsis_gcc.h **** {
 406:CMSIS/cmsis_gcc.h ****   __ASM volatile ("sev");
 309              		.loc 2 406 3 view .LVU54
 310              		.syntax unified
 311              	@ 406 "CMSIS/cmsis_gcc.h" 1
 312 000e 40BF     		sev
 313              	@ 0 "" 2
 314              		.thumb
 315              		.syntax unified
 316              	.LBE21:
 317              	.LBE20:
 262:./lib/src/at32f4xx_pwr.c ****     __WFE();
 318              		.loc 1 262 5 view .LVU55
ARM GAS  /tmp/ccyyqHbL.s 			page 18


 319              	.LBB22:
 320              	.LBI22:
 394:CMSIS/cmsis_gcc.h **** {
 321              		.loc 2 394 53 view .LVU56
 322              	.LBB23:
 396:CMSIS/cmsis_gcc.h **** }
 323              		.loc 2 396 3 view .LVU57
 324              		.syntax unified
 325              	@ 396 "CMSIS/cmsis_gcc.h" 1
 326 0010 20BF     		wfe
 327              	@ 0 "" 2
 328              		.thumb
 329              		.syntax unified
 330              	.LBE23:
 331              	.LBE22:
 263:./lib/src/at32f4xx_pwr.c ****     __WFE();
 332              		.loc 1 263 5 view .LVU58
 333              	.LBB24:
 334              	.LBI24:
 394:CMSIS/cmsis_gcc.h **** {
 335              		.loc 2 394 53 view .LVU59
 336              	.LBB25:
 396:CMSIS/cmsis_gcc.h **** }
 337              		.loc 2 396 3 view .LVU60
 338              		.syntax unified
 339              	@ 396 "CMSIS/cmsis_gcc.h" 1
 340 0012 20BF     		wfe
 341              	@ 0 "" 2
 342              		.thumb
 343              		.syntax unified
 344              	.LBE25:
 345              	.LBE24:
 264:./lib/src/at32f4xx_pwr.c ****   }
 265:./lib/src/at32f4xx_pwr.c **** }
 346              		.loc 1 265 1 is_stmt 0 view .LVU61
 347 0014 7047     		bx	lr
 348              	.L27:
 256:./lib/src/at32f4xx_pwr.c ****   }
 349              		.loc 1 256 5 is_stmt 1 view .LVU62
 350              	.LBB26:
 351              	.LBI26:
 383:CMSIS/cmsis_gcc.h **** {
 352              		.loc 2 383 53 view .LVU63
 353              	.LBB27:
 385:CMSIS/cmsis_gcc.h **** }
 354              		.loc 2 385 3 view .LVU64
 355              		.syntax unified
 356              	@ 385 "CMSIS/cmsis_gcc.h" 1
 357 0016 30BF     		wfi
 358              	@ 0 "" 2
 386:CMSIS/cmsis_gcc.h **** 
 359              		.loc 2 386 1 is_stmt 0 view .LVU65
 360              		.thumb
 361              		.syntax unified
 362 0018 7047     		bx	lr
 363              	.L29:
 364 001a 00BF     		.align	2
ARM GAS  /tmp/ccyyqHbL.s 			page 19


 365              	.L28:
 366 001c 00ED00E0 		.word	-536810240
 367              	.LBE27:
 368              	.LBE26:
 369              		.cfi_endproc
 370              	.LFE131:
 372              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 373              		.align	1
 374              		.global	PWR_EnterSTOPMode
 375              		.syntax unified
 376              		.thumb
 377              		.thumb_func
 378              		.fpu fpv4-sp-d16
 380              	PWR_EnterSTOPMode:
 381              	.LVL13:
 382              	.LFB132:
 266:./lib/src/at32f4xx_pwr.c **** 
 267:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F403xx) || defined (AT32F413xx)
 268:./lib/src/at32f4xx_pwr.c **** /**
 269:./lib/src/at32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 270:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 271:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 272:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 273:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 274:./lib/src/at32f4xx_pwr.c ****   * @retval None
 275:./lib/src/at32f4xx_pwr.c ****   */
 276:./lib/src/at32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint8_t PWR_STOPEntry)
 277:./lib/src/at32f4xx_pwr.c **** {
 278:./lib/src/at32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 279:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 280:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 281:./lib/src/at32f4xx_pwr.c **** 
 282:./lib/src/at32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 283:./lib/src/at32f4xx_pwr.c ****   tmpreg = PWR->CTRL;
 284:./lib/src/at32f4xx_pwr.c ****   /* Clear PDDS bit */
 285:./lib/src/at32f4xx_pwr.c ****   tmpreg &= ~CTRL_LPDS_MASK;
 286:./lib/src/at32f4xx_pwr.c ****   /* Store the new value */
 287:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL = tmpreg;
 288:./lib/src/at32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 289:./lib/src/at32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP;
 290:./lib/src/at32f4xx_pwr.c **** 
 291:./lib/src/at32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 292:./lib/src/at32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 293:./lib/src/at32f4xx_pwr.c ****   {
 294:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 295:./lib/src/at32f4xx_pwr.c ****     __WFI();
 296:./lib/src/at32f4xx_pwr.c ****   }
 297:./lib/src/at32f4xx_pwr.c ****   else
 298:./lib/src/at32f4xx_pwr.c ****   {
 299:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Event */
 300:./lib/src/at32f4xx_pwr.c ****     __SEV();
 301:./lib/src/at32f4xx_pwr.c ****     __WFE();
 302:./lib/src/at32f4xx_pwr.c ****     __WFE();
 303:./lib/src/at32f4xx_pwr.c ****   }
 304:./lib/src/at32f4xx_pwr.c **** 
 305:./lib/src/at32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 306:./lib/src/at32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
ARM GAS  /tmp/ccyyqHbL.s 			page 20


 307:./lib/src/at32f4xx_pwr.c **** }
 308:./lib/src/at32f4xx_pwr.c **** #else
 309:./lib/src/at32f4xx_pwr.c **** /**
 310:./lib/src/at32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 311:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 312:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 313:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_Regulator_ON: STOP mode with regulator ON
 314:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 315:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 316:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 317:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 318:./lib/src/at32f4xx_pwr.c ****   * @retval None
 319:./lib/src/at32f4xx_pwr.c ****   */
 320:./lib/src/at32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 321:./lib/src/at32f4xx_pwr.c **** {
 383              		.loc 1 321 1 is_stmt 1 view -0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 0
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              		@ link register save eliminated.
 322:./lib/src/at32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 388              		.loc 1 322 3 view .LVU67
 323:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 324:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 389              		.loc 1 324 3 view .LVU68
 325:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 390              		.loc 1 325 3 view .LVU69
 326:./lib/src/at32f4xx_pwr.c **** 
 327:./lib/src/at32f4xx_pwr.c **** #if defined (AT32F421xx)
 328:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL2 &= ~CTRL2_LPDS1_MASK;
 391              		.loc 1 328 3 view .LVU70
 392              		.loc 1 328 14 is_stmt 0 view .LVU71
 393 0000 104B     		ldr	r3, .L34
 394 0002 1A6A     		ldr	r2, [r3, #32]
 395 0004 22F02002 		bic	r2, r2, #32
 396 0008 1A62     		str	r2, [r3, #32]
 329:./lib/src/at32f4xx_pwr.c ****   tmpreg = PWR_Regulator & CTRL2_LPDS1_MASK;
 397              		.loc 1 329 3 is_stmt 1 view .LVU72
 398              		.loc 1 329 10 is_stmt 0 view .LVU73
 399 000a 00F02002 		and	r2, r0, #32
 400              	.LVL14:
 330:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL2 = tmpreg;
 401              		.loc 1 330 3 is_stmt 1 view .LVU74
 402              		.loc 1 330 14 is_stmt 0 view .LVU75
 403 000e 1A62     		str	r2, [r3, #32]
 331:./lib/src/at32f4xx_pwr.c **** #endif
 332:./lib/src/at32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 333:./lib/src/at32f4xx_pwr.c ****   tmpreg = PWR->CTRL;
 404              		.loc 1 333 3 is_stmt 1 view .LVU76
 405              		.loc 1 333 10 is_stmt 0 view .LVU77
 406 0010 1A68     		ldr	r2, [r3]
 407              	.LVL15:
 334:./lib/src/at32f4xx_pwr.c ****   /* Clear PDDS bit */
 335:./lib/src/at32f4xx_pwr.c ****   tmpreg &= ~CTRL_LPDS_MASK;
 408              		.loc 1 335 3 is_stmt 1 view .LVU78
 409              		.loc 1 335 10 is_stmt 0 view .LVU79
 410 0012 22F00302 		bic	r2, r2, #3
ARM GAS  /tmp/ccyyqHbL.s 			page 21


 411              	.LVL16:
 336:./lib/src/at32f4xx_pwr.c ****   /* Set PWR_Regulator value */
 337:./lib/src/at32f4xx_pwr.c ****   tmpreg |= PWR_Regulator & CTRL_LPDS_MASK;
 412              		.loc 1 337 3 is_stmt 1 view .LVU80
 413              		.loc 1 337 27 is_stmt 0 view .LVU81
 414 0016 00F00300 		and	r0, r0, #3
 415              	.LVL17:
 416              		.loc 1 337 10 view .LVU82
 417 001a 1043     		orrs	r0, r0, r2
 418              	.LVL18:
 338:./lib/src/at32f4xx_pwr.c ****   /* Store the new value */
 339:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL = tmpreg;
 419              		.loc 1 339 3 is_stmt 1 view .LVU83
 420              		.loc 1 339 13 is_stmt 0 view .LVU84
 421 001c 1860     		str	r0, [r3]
 340:./lib/src/at32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 341:./lib/src/at32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP;
 422              		.loc 1 341 3 is_stmt 1 view .LVU85
 423              		.loc 1 341 12 is_stmt 0 view .LVU86
 424 001e 0A4A     		ldr	r2, .L34+4
 425 0020 1369     		ldr	r3, [r2, #16]
 426 0022 43F00403 		orr	r3, r3, #4
 427 0026 1361     		str	r3, [r2, #16]
 342:./lib/src/at32f4xx_pwr.c **** 
 343:./lib/src/at32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 344:./lib/src/at32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 428              		.loc 1 344 3 is_stmt 1 view .LVU87
 429              		.loc 1 344 5 is_stmt 0 view .LVU88
 430 0028 0129     		cmp	r1, #1
 431 002a 08D0     		beq	.L33
 345:./lib/src/at32f4xx_pwr.c ****   {
 346:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 347:./lib/src/at32f4xx_pwr.c ****     __WFI();
 348:./lib/src/at32f4xx_pwr.c ****   }
 349:./lib/src/at32f4xx_pwr.c ****   else
 350:./lib/src/at32f4xx_pwr.c ****   {
 351:./lib/src/at32f4xx_pwr.c ****     /* Request Wait For Event */
 352:./lib/src/at32f4xx_pwr.c ****     __SEV();
 432              		.loc 1 352 5 is_stmt 1 view .LVU89
 433              	.LBB28:
 434              	.LBI28:
 404:CMSIS/cmsis_gcc.h **** {
 435              		.loc 2 404 53 view .LVU90
 436              	.LBB29:
 437              		.loc 2 406 3 view .LVU91
 438              		.syntax unified
 439              	@ 406 "CMSIS/cmsis_gcc.h" 1
 440 002c 40BF     		sev
 441              	@ 0 "" 2
 442              		.thumb
 443              		.syntax unified
 444              	.LBE29:
 445              	.LBE28:
 353:./lib/src/at32f4xx_pwr.c ****     __WFE();
 446              		.loc 1 353 5 view .LVU92
 447              	.LBB30:
 448              	.LBI30:
ARM GAS  /tmp/ccyyqHbL.s 			page 22


 394:CMSIS/cmsis_gcc.h **** {
 449              		.loc 2 394 53 view .LVU93
 450              	.LBB31:
 396:CMSIS/cmsis_gcc.h **** }
 451              		.loc 2 396 3 view .LVU94
 452              		.syntax unified
 453              	@ 396 "CMSIS/cmsis_gcc.h" 1
 454 002e 20BF     		wfe
 455              	@ 0 "" 2
 456              		.thumb
 457              		.syntax unified
 458              	.LBE31:
 459              	.LBE30:
 354:./lib/src/at32f4xx_pwr.c ****     __WFE();
 460              		.loc 1 354 5 view .LVU95
 461              	.LBB32:
 462              	.LBI32:
 394:CMSIS/cmsis_gcc.h **** {
 463              		.loc 2 394 53 view .LVU96
 464              	.LBB33:
 396:CMSIS/cmsis_gcc.h **** }
 465              		.loc 2 396 3 view .LVU97
 466              		.syntax unified
 467              	@ 396 "CMSIS/cmsis_gcc.h" 1
 468 0030 20BF     		wfe
 469              	@ 0 "" 2
 470              		.thumb
 471              		.syntax unified
 472              	.L32:
 473              	.LBE33:
 474              	.LBE32:
 355:./lib/src/at32f4xx_pwr.c ****   }
 356:./lib/src/at32f4xx_pwr.c **** 
 357:./lib/src/at32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 358:./lib/src/at32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
 475              		.loc 1 358 3 view .LVU98
 476              		.loc 1 358 12 is_stmt 0 view .LVU99
 477 0032 054A     		ldr	r2, .L34+4
 478 0034 1369     		ldr	r3, [r2, #16]
 479 0036 23F00403 		bic	r3, r3, #4
 480 003a 1361     		str	r3, [r2, #16]
 359:./lib/src/at32f4xx_pwr.c **** }
 481              		.loc 1 359 1 view .LVU100
 482 003c 7047     		bx	lr
 483              	.L33:
 347:./lib/src/at32f4xx_pwr.c ****   }
 484              		.loc 1 347 5 is_stmt 1 view .LVU101
 485              	.LBB34:
 486              	.LBI34:
 383:CMSIS/cmsis_gcc.h **** {
 487              		.loc 2 383 53 view .LVU102
 488              	.LBB35:
 385:CMSIS/cmsis_gcc.h **** }
 489              		.loc 2 385 3 view .LVU103
 490              		.syntax unified
 491              	@ 385 "CMSIS/cmsis_gcc.h" 1
 492 003e 30BF     		wfi
ARM GAS  /tmp/ccyyqHbL.s 			page 23


 493              	@ 0 "" 2
 386:CMSIS/cmsis_gcc.h **** 
 494              		.loc 2 386 1 is_stmt 0 view .LVU104
 495              		.thumb
 496              		.syntax unified
 497 0040 F7E7     		b	.L32
 498              	.L35:
 499 0042 00BF     		.align	2
 500              	.L34:
 501 0044 00700040 		.word	1073770496
 502 0048 00ED00E0 		.word	-536810240
 503              	.LBE35:
 504              	.LBE34:
 505              		.cfi_endproc
 506              	.LFE132:
 508              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 509              		.align	1
 510              		.global	PWR_EnterSTANDBYMode
 511              		.syntax unified
 512              		.thumb
 513              		.thumb_func
 514              		.fpu fpv4-sp-d16
 516              	PWR_EnterSTANDBYMode:
 517              	.LFB133:
 360:./lib/src/at32f4xx_pwr.c **** #endif
 361:./lib/src/at32f4xx_pwr.c **** 
 362:./lib/src/at32f4xx_pwr.c **** /**
 363:./lib/src/at32f4xx_pwr.c ****   * @brief  Enters STANDBY mode.
 364:./lib/src/at32f4xx_pwr.c ****   * @param  None
 365:./lib/src/at32f4xx_pwr.c ****   * @retval None
 366:./lib/src/at32f4xx_pwr.c ****   */
 367:./lib/src/at32f4xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 368:./lib/src/at32f4xx_pwr.c **** {
 518              		.loc 1 368 1 is_stmt 1 view -0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 0
 521              		@ frame_needed = 0, uses_anonymous_args = 0
 522              		@ link register save eliminated.
 369:./lib/src/at32f4xx_pwr.c ****   /* Clear Wake-up flag */
 370:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL |= PWR_CTRL_CLWUF;
 523              		.loc 1 370 3 view .LVU106
 524              		.loc 1 370 13 is_stmt 0 view .LVU107
 525 0000 074B     		ldr	r3, .L37
 526 0002 1A68     		ldr	r2, [r3]
 527 0004 42F00402 		orr	r2, r2, #4
 528 0008 1A60     		str	r2, [r3]
 371:./lib/src/at32f4xx_pwr.c ****   /* Select STANDBY mode */
 372:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL |= PWR_CTRL_PDDS;
 529              		.loc 1 372 3 is_stmt 1 view .LVU108
 530              		.loc 1 372 13 is_stmt 0 view .LVU109
 531 000a 1A68     		ldr	r2, [r3]
 532 000c 42F00202 		orr	r2, r2, #2
 533 0010 1A60     		str	r2, [r3]
 373:./lib/src/at32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 374:./lib/src/at32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP;
 534              		.loc 1 374 3 is_stmt 1 view .LVU110
 535              		.loc 1 374 12 is_stmt 0 view .LVU111
ARM GAS  /tmp/ccyyqHbL.s 			page 24


 536 0012 044A     		ldr	r2, .L37+4
 537 0014 1369     		ldr	r3, [r2, #16]
 538 0016 43F00403 		orr	r3, r3, #4
 539 001a 1361     		str	r3, [r2, #16]
 375:./lib/src/at32f4xx_pwr.c ****   /* This option is used to ensure that store operations are completed */
 376:./lib/src/at32f4xx_pwr.c **** #if defined ( __CC_ARM   )
 377:./lib/src/at32f4xx_pwr.c ****   __force_stores();
 378:./lib/src/at32f4xx_pwr.c **** #endif
 379:./lib/src/at32f4xx_pwr.c ****   /* Request Wait For Interrupt */
 380:./lib/src/at32f4xx_pwr.c ****   __WFI();
 540              		.loc 1 380 3 is_stmt 1 view .LVU112
 541              	.LBB36:
 542              	.LBI36:
 383:CMSIS/cmsis_gcc.h **** {
 543              		.loc 2 383 53 view .LVU113
 544              	.LBB37:
 385:CMSIS/cmsis_gcc.h **** }
 545              		.loc 2 385 3 view .LVU114
 546              		.syntax unified
 547              	@ 385 "CMSIS/cmsis_gcc.h" 1
 548 001c 30BF     		wfi
 549              	@ 0 "" 2
 550              		.thumb
 551              		.syntax unified
 552              	.LBE37:
 553              	.LBE36:
 381:./lib/src/at32f4xx_pwr.c **** }
 554              		.loc 1 381 1 is_stmt 0 view .LVU115
 555 001e 7047     		bx	lr
 556              	.L38:
 557              		.align	2
 558              	.L37:
 559 0020 00700040 		.word	1073770496
 560 0024 00ED00E0 		.word	-536810240
 561              		.cfi_endproc
 562              	.LFE133:
 564              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 565              		.align	1
 566              		.global	PWR_GetFlagStatus
 567              		.syntax unified
 568              		.thumb
 569              		.thumb_func
 570              		.fpu fpv4-sp-d16
 572              	PWR_GetFlagStatus:
 573              	.LVL19:
 574              	.LFB134:
 382:./lib/src/at32f4xx_pwr.c **** 
 383:./lib/src/at32f4xx_pwr.c **** /**
 384:./lib/src/at32f4xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 385:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 386:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 387:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_FLAG_WUF: Wake Up flag
 388:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_FLAG_SBF: StandBy flag
 389:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_FLAG_PVDO: PVD Output
 390:./lib/src/at32f4xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 391:./lib/src/at32f4xx_pwr.c ****   */
 392:./lib/src/at32f4xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
ARM GAS  /tmp/ccyyqHbL.s 			page 25


 393:./lib/src/at32f4xx_pwr.c **** {
 575              		.loc 1 393 1 is_stmt 1 view -0
 576              		.cfi_startproc
 577              		@ args = 0, pretend = 0, frame = 0
 578              		@ frame_needed = 0, uses_anonymous_args = 0
 579              		@ link register save eliminated.
 394:./lib/src/at32f4xx_pwr.c ****   FlagStatus bitstatus = RESET;
 580              		.loc 1 394 3 view .LVU117
 395:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 396:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 581              		.loc 1 396 3 view .LVU118
 397:./lib/src/at32f4xx_pwr.c **** 
 398:./lib/src/at32f4xx_pwr.c ****   if ((PWR->CTRLSTS & PWR_FLAG) != (uint32_t)RESET)
 582              		.loc 1 398 3 view .LVU119
 583              		.loc 1 398 11 is_stmt 0 view .LVU120
 584 0000 034B     		ldr	r3, .L42
 585 0002 5B68     		ldr	r3, [r3, #4]
 586              		.loc 1 398 6 view .LVU121
 587 0004 0342     		tst	r3, r0
 588 0006 01D0     		beq	.L41
 399:./lib/src/at32f4xx_pwr.c ****   {
 400:./lib/src/at32f4xx_pwr.c ****     bitstatus = SET;
 589              		.loc 1 400 15 view .LVU122
 590 0008 0120     		movs	r0, #1
 591              	.LVL20:
 592              		.loc 1 400 15 view .LVU123
 593 000a 7047     		bx	lr
 594              	.LVL21:
 595              	.L41:
 401:./lib/src/at32f4xx_pwr.c ****   }
 402:./lib/src/at32f4xx_pwr.c ****   else
 403:./lib/src/at32f4xx_pwr.c ****   {
 404:./lib/src/at32f4xx_pwr.c ****     bitstatus = RESET;
 596              		.loc 1 404 15 view .LVU124
 597 000c 0020     		movs	r0, #0
 598              	.LVL22:
 405:./lib/src/at32f4xx_pwr.c ****   }
 406:./lib/src/at32f4xx_pwr.c **** 
 407:./lib/src/at32f4xx_pwr.c ****   /* Return the flag status */
 408:./lib/src/at32f4xx_pwr.c ****   return bitstatus;
 599              		.loc 1 408 3 is_stmt 1 view .LVU125
 409:./lib/src/at32f4xx_pwr.c **** }
 600              		.loc 1 409 1 is_stmt 0 view .LVU126
 601 000e 7047     		bx	lr
 602              	.L43:
 603              		.align	2
 604              	.L42:
 605 0010 00700040 		.word	1073770496
 606              		.cfi_endproc
 607              	.LFE134:
 609              		.section	.text.PWR_ClearFlag,"ax",%progbits
 610              		.align	1
 611              		.global	PWR_ClearFlag
 612              		.syntax unified
 613              		.thumb
 614              		.thumb_func
 615              		.fpu fpv4-sp-d16
ARM GAS  /tmp/ccyyqHbL.s 			page 26


 617              	PWR_ClearFlag:
 618              	.LVL23:
 619              	.LFB135:
 410:./lib/src/at32f4xx_pwr.c **** 
 411:./lib/src/at32f4xx_pwr.c **** /**
 412:./lib/src/at32f4xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
 413:./lib/src/at32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 414:./lib/src/at32f4xx_pwr.c ****   *   This parameter can be one of the following values:
 415:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_FLAG_WUF: Wake Up flag
 416:./lib/src/at32f4xx_pwr.c ****   *     @arg PWR_FLAG_SBF: StandBy flag
 417:./lib/src/at32f4xx_pwr.c ****   * @retval None
 418:./lib/src/at32f4xx_pwr.c ****   */
 419:./lib/src/at32f4xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 420:./lib/src/at32f4xx_pwr.c **** {
 620              		.loc 1 420 1 is_stmt 1 view -0
 621              		.cfi_startproc
 622              		@ args = 0, pretend = 0, frame = 0
 623              		@ frame_needed = 0, uses_anonymous_args = 0
 624              		@ link register save eliminated.
 421:./lib/src/at32f4xx_pwr.c ****   /* Check the parameters */
 422:./lib/src/at32f4xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 625              		.loc 1 422 3 view .LVU128
 423:./lib/src/at32f4xx_pwr.c **** 
 424:./lib/src/at32f4xx_pwr.c ****   PWR->CTRL |=  PWR_FLAG << 2;
 626              		.loc 1 424 3 view .LVU129
 627              		.loc 1 424 13 is_stmt 0 view .LVU130
 628 0000 024A     		ldr	r2, .L45
 629 0002 1368     		ldr	r3, [r2]
 630 0004 43EA8003 		orr	r3, r3, r0, lsl #2
 631 0008 1360     		str	r3, [r2]
 425:./lib/src/at32f4xx_pwr.c **** }
 632              		.loc 1 425 1 view .LVU131
 633 000a 7047     		bx	lr
 634              	.L46:
 635              		.align	2
 636              	.L45:
 637 000c 00700040 		.word	1073770496
 638              		.cfi_endproc
 639              	.LFE135:
 641              		.text
 642              	.Letext0:
 643              		.file 3 "/usr/lib/gcc/arm-none-eabi/10.3.1/include/stdint.h"
 644              		.file 4 "CMSIS/core_cm4.h"
 645              		.file 5 "CMSIS/at32f4xx.h"
 646              		.file 6 "lib/inc/at32f4xx_rcc.h"
ARM GAS  /tmp/ccyyqHbL.s 			page 27


DEFINED SYMBOLS
                            *ABS*:0000000000000000 at32f4xx_pwr.c
     /tmp/ccyyqHbL.s:18     .text.PWR_Reset:0000000000000000 $t
     /tmp/ccyyqHbL.s:26     .text.PWR_Reset:0000000000000000 PWR_Reset
     /tmp/ccyyqHbL.s:54     .text.PWR_BackupAccessCtrl:0000000000000000 $t
     /tmp/ccyyqHbL.s:61     .text.PWR_BackupAccessCtrl:0000000000000000 PWR_BackupAccessCtrl
     /tmp/ccyyqHbL.s:79     .text.PWR_BackupAccessCtrl:0000000000000008 $d
     /tmp/ccyyqHbL.s:84     .text.PWR_PVDCtrl:0000000000000000 $t
     /tmp/ccyyqHbL.s:91     .text.PWR_PVDCtrl:0000000000000000 PWR_PVDCtrl
     /tmp/ccyyqHbL.s:109    .text.PWR_PVDCtrl:0000000000000008 $d
     /tmp/ccyyqHbL.s:114    .text.PWR_PVDLevelConfig:0000000000000000 $t
     /tmp/ccyyqHbL.s:121    .text.PWR_PVDLevelConfig:0000000000000000 PWR_PVDLevelConfig
     /tmp/ccyyqHbL.s:152    .text.PWR_PVDLevelConfig:0000000000000010 $d
     /tmp/ccyyqHbL.s:157    .text.PWR_WakeUpPinCtrl:0000000000000000 $t
     /tmp/ccyyqHbL.s:164    .text.PWR_WakeUpPinCtrl:0000000000000000 PWR_WakeUpPinCtrl
     /tmp/ccyyqHbL.s:182    .text.PWR_WakeUpPinCtrl:0000000000000008 $d
     /tmp/ccyyqHbL.s:187    .text.PWR_WakeUpPinCtrl2:0000000000000000 $t
     /tmp/ccyyqHbL.s:194    .text.PWR_WakeUpPinCtrl2:0000000000000000 PWR_WakeUpPinCtrl2
     /tmp/ccyyqHbL.s:212    .text.PWR_WakeUpPinCtrl2:0000000000000008 $d
     /tmp/ccyyqHbL.s:217    .text.PWR_WakeUpPinCtrl6:0000000000000000 $t
     /tmp/ccyyqHbL.s:224    .text.PWR_WakeUpPinCtrl6:0000000000000000 PWR_WakeUpPinCtrl6
     /tmp/ccyyqHbL.s:242    .text.PWR_WakeUpPinCtrl6:0000000000000008 $d
     /tmp/ccyyqHbL.s:247    .text.PWR_WakeUpPinCtrl7:0000000000000000 $t
     /tmp/ccyyqHbL.s:254    .text.PWR_WakeUpPinCtrl7:0000000000000000 PWR_WakeUpPinCtrl7
     /tmp/ccyyqHbL.s:272    .text.PWR_WakeUpPinCtrl7:0000000000000008 $d
     /tmp/ccyyqHbL.s:277    .text.PWR_EnterSleepMode:0000000000000000 $t
     /tmp/ccyyqHbL.s:284    .text.PWR_EnterSleepMode:0000000000000000 PWR_EnterSleepMode
     /tmp/ccyyqHbL.s:366    .text.PWR_EnterSleepMode:000000000000001c $d
     /tmp/ccyyqHbL.s:373    .text.PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccyyqHbL.s:380    .text.PWR_EnterSTOPMode:0000000000000000 PWR_EnterSTOPMode
     /tmp/ccyyqHbL.s:501    .text.PWR_EnterSTOPMode:0000000000000044 $d
     /tmp/ccyyqHbL.s:509    .text.PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccyyqHbL.s:516    .text.PWR_EnterSTANDBYMode:0000000000000000 PWR_EnterSTANDBYMode
     /tmp/ccyyqHbL.s:559    .text.PWR_EnterSTANDBYMode:0000000000000020 $d
     /tmp/ccyyqHbL.s:565    .text.PWR_GetFlagStatus:0000000000000000 $t
     /tmp/ccyyqHbL.s:572    .text.PWR_GetFlagStatus:0000000000000000 PWR_GetFlagStatus
     /tmp/ccyyqHbL.s:605    .text.PWR_GetFlagStatus:0000000000000010 $d
     /tmp/ccyyqHbL.s:610    .text.PWR_ClearFlag:0000000000000000 $t
     /tmp/ccyyqHbL.s:617    .text.PWR_ClearFlag:0000000000000000 PWR_ClearFlag
     /tmp/ccyyqHbL.s:637    .text.PWR_ClearFlag:000000000000000c $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
